<template>
  <div class="chat-page">
    <!-- Если чат не выбран или данные еще не загружены -->
    <div v-if="!chatData || !chatData._id" class="no-chat-selected">
      Выберите чат, чтобы начать общение
    </div>
    
    <!-- Если чат выбран -->
    <div v-else class="chat-content">
      <!-- Шапка чата -->
      <div class="page_header" @click="openChatSettings">
        <!-- Кнопка переключения боковой панели для мобильных устройств -->
        <button class="toggle-sidebar-btn" @click.stop="toggleSidebar">
          <IconBottomArrow class="toggle-sidebar-btn__icon" filled />
        </button>
        
        <div class="content">
          <div 
            class="content__img" 
            :style="chatData.avatar ? `background-image: url(${secureUrl(chatData.avatar)})` : ''"
          >
            <div v-if="!chatData.avatar" class="initials">
              {{ getInitials(chatData.name) }}
            </div>
          </div>
          <div class="content__textblock">
            <div class="text bold">{{ chatData.name }}</div>
            <div class="text member">{{ chatData.participants?.length || 0 }} участник(ов)</div>
          </div>
        </div>
        
        <div class="chat-actions">
        </div>
      </div>
      
      <!-- Контейнер сообщений -->
      <div class="messages_container" ref="messagesContainer" @scroll="checkIfAtBottom">        
        <!-- Индикатор загрузки дополнительных сообщений -->
        <div v-if="chatStore.loadingMore" class="loading-indicator loading-more">
          <div class="spinner"></div>
          <span>Загрузка старых сообщений...</span>
        </div>
        
        <!-- Индикатор первичной загрузки -->
        <div v-if="chatStore.loading && !visibleMessages.length" class="loading-indicator initial-loading">
          <div class="spinner"></div>
          <span>Загрузка сообщений...</span>
        </div>
        
        <!-- Если сообщений нет -->
        <div v-if="!chatStore.loading && messages.length === 0" class="empty-chat">
          Нет сообщений. Начните общение!
        </div>
        
        <!-- Сообщения, сгруппированные по датам -->
        <div v-for="group in groupedMessages" :key="group.date">
          <!-- Заголовок с датой -->
          <div class="date-header">
            <span>{{ formatDate(group.date) }}</span>
          </div>
          
          <!-- Сообщения группы -->
          <div v-for="message in group.messages" :key="message._id" class="message_wrap">
            <!-- Service message -->
            <div v-if="message.type === 'service'" class="service_message">
              <div>{{ message.text }}</div>
              <div class="time">{{ formatTime(message.createdAt || message.timestamp) }}</div>
            </div>
            
            <!-- Regular message -->
            <div 
              v-else 
              class="message" 
              :class="isOwnMessage(message) ? 'own' : 'other'"
              @contextmenu.prevent="showContextMenu($event, message)"
              @click="handleMessageClick($event, message)"
            >
              <!-- Имя отправителя (для групповых чатов) -->
              <div 
                v-if="!isOwnMessage(message) && chatData.participants?.length > 2" 
                class="message__from"
              >
                {{ message.sender?.name }}
              </div>
              
              <!-- Контент сообщения -->
              <div class="message__content">
                <!-- Имя отправителя (для групповых чатов) -->
                <div 
                  v-if="!isOwnMessage(message) && chatData.participants?.length > 2 && message.media_type !== 'none'" 
                  class="message__from"
                >
                  {{ message.sender?.name }}
                </div>
                
                <!-- Message content based on type -->
                <div v-if="message.media_type === 'none'" class="message__text">
                  <pre>{{ message.text }}</pre>
                </div>
                
                <div v-else-if="message.media_type === 'image'" class="image-container">
                  <div v-if="!message.imageLoaded" class="image-loading">
                    <div class="loading-spinner"></div>
                  </div>
                  <img 
                    :src="message.file" 
                    alt="Image" 
                    class="message-image" 
                    @load="message.imageLoaded = true"
                    :class="{ 'loaded': message.imageLoaded }"
                  />
                </div>
                
                <div v-else-if="message.media_type === 'video'" class="video-container">
                  <video 
                    :id="message._id" 
                    class="video-message-player" 
                    controls 
                    :src="message.file"
                  ></video>
                </div>
                
                <div v-else-if="message.media_type === 'sticker'" class="sticker-container">
                  <img :src="message.file" alt="Sticker" class="message-sticker" />
                </div>
                
                <div v-else-if="message.media_type === 'file'" class="file-container">
                  <a :href="message.file" target="_blank" class="file-link">
                    <i class="fas fa-file file-icon"></i>
                    {{ message.fileName || 'Файл' }}
                  </a>
                </div>
                
                <div class="message__time">
                  {{ formatTime(message.createdAt || message.timestamp) }}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Индикатор новых сообщений -->
        <transition name="scroll-btn">
          <ChatNewMessagesButton 
            v-if="!isAtBottom && !chatStore.loadingMore && messages.length > 0" 
            @click="scrollToNewMessages" 
          />
        </transition>
      </div>
      
      <!-- Input area -->
      <div class="input_area" ref="inputArea">
        <!-- Индикатор редактирования сообщения -->
        <div v-if="isEditingMessage" class="editing-indicator">
          <div class="editing-text">
            <i class="fas fa-edit"></i> Редактирование: {{ originalMessageText.length > 30 ? originalMessageText.substring(0, 30) + '...' : originalMessageText }}
          </div>
          <button class="cancel-btn" @click="cancelEditingMessage">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="input_container" ref="inputContainer">
          <textarea 
            v-model="messageText" 
            class="inp inp--textarea message_input" 
            placeholder="Введите сообщение..." 
            @keydown.enter.exact.prevent="handleEnterKey"
            @keydown.shift.enter.prevent="addNewLine"
            @input="adjustTextareaHeight"
            ref="messageInput"
            rows="1"
          ></textarea>
          <div class="button_container">
            <button 
              type="button" 
              class="send_button"
              :disabled="!messageText.trim()"
              @click="sendMessage"
            >
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <ChatSettingsModal 
    v-if="showChatSettingsModal" 
    :is-open="showChatSettingsModal" 
    :chat-data="chatData" 
    :is-new-chat="false" 
    @close="showChatSettingsModal = false" 
    @saved="onChatUpdated" 
  />
  <ChatMessageContextMenu 
    v-if="contextMenuVisible" 
    :is-visible="contextMenuVisible"
    :position="contextMenuPosition" 
    :message="selectedMessage"
    @close="hideContextMenu"
    @edit="startEditingMessage"
    @delete="deleteMessage"
  />
</template>

<script setup>
import { useChatStore } from '~/stores/chat';
import { useAuthStore } from '~/stores/auth';
import { secureUrl } from '~/utils/secureUrl';

// Хранилища
const chatStore = useChatStore();
const authStore = useAuthStore();

// Данные чата и сообщений
const chatData = computed(() => {
  return chatStore.activeChat;
});

const messages = computed(() => {
  return chatStore.messages;
});

// Состояние прокрутки чата
const isAtBottom = ref(true);
const messagesContainer = ref(null);
const showNewMessageIndicator = ref(false);

// Ссылки на элементы
const inputArea = ref(null);
const messageInput = ref(null);
const inputContainer = ref(null);
const pageHeader = ref(null);

// Функция для проверки, находится ли пользователь внизу чата
const checkIfAtBottom = () => {
  if (!messagesContainer.value) return true;
  
  const container = messagesContainer.value;
  const scrollPosition = container.scrollTop + container.clientHeight;
  const scrollHeight = container.scrollHeight;
  
  // Считаем, что пользователь внизу, если он находится в пределах 100px от нижней границы
  isAtBottom.value = scrollHeight - scrollPosition < 100;
  
  // Если пользователь прокрутил вниз до конца, скрываем индикатор новых сообщений
  if (isAtBottom.value) {
    showNewMessageIndicator.value = false;
  }
  
  return isAtBottom.value;
};

// Функция для прокрутки к новым сообщениям
const scrollToNewMessages = () => {
  scrollToBottom(true);
  showNewMessageIndicator.value = false;
};

// Состояние загрузки
const loading = computed(() => chatStore.loading);

const showChatSettingsModal = ref(false);

// Обработка обновления чата после сохранения в модальном окне
const onChatUpdated = () => {
  // Обновляем данные чата, если необходимо
  if (chatData.value && chatData.value._id) {
    chatStore.setActiveChat(chatData.value._id);
  }
};

// Видимые сообщения (для бесконечной прокрутки)
const visibleMessages = ref([]);
const loadingTrigger = ref(null);
const observer = ref(null);
const messageText = ref('');

// Состояния для контекстного меню сообщений
const contextMenuVisible = ref(false);
const contextMenuPosition = ref({ x: 0, y: 0 });
const selectedMessage = ref(null);

// Состояние редактирования сообщения
const isEditingMessage = ref(false);
const editingMessageText = ref('');
const originalMessageText = ref('');

// Данные для управления воспроизведением видео
const playbackControlData = ref({
  isActive: false,
  username: '',
  speed: 1,
  videoId: null
});

// Группировка сообщений по датам
const groupedMessages = computed(() => {
  // Проверяем, что сообщения существуют
  if (!messages.value || !Array.isArray(messages.value)) {
    return [];
  }
  
  const groups = {};
  messages.value.forEach(message => {
    if (!message) return; // Пропускаем недействительные сообщения
    
    // Безопасно получаем дату
    const timestamp = message.createdAt || message.timestamp;
    if (!timestamp) return; // Пропускаем сообщения без времени
    
    const date = new Date(timestamp);
    const key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
    if (!groups[key]) {
      groups[key] = {
        date: key,
        messages: []
      };
    }
    groups[key].messages.push(message);
  });
  return Object.values(groups);
});

// Настройка бесконечной прокрутки
const setupInfiniteScroll = () => {
  // Отключаем предыдущий observer, если он существует
  if (observer.value) {
    observer.value.disconnect();
  }
  
  // Создаем новый Intersection Observer для бесконечной прокрутки
  observer.value = new IntersectionObserver(async (entries) => {
    const entry = entries[0];
    
    // Если триггер виден и есть еще сообщения для загрузки
    if (entry.isIntersecting && chatStore.pagination.hasMore && !chatStore.loadingMore) {
      chatStore.loadingMore = true;
      
      try {
        // Получаем ID самого старого сообщения
        const oldestMessageId = chatStore.pagination.nextCursor;
        
        if (oldestMessageId) {
          // Загружаем более старые сообщения
          await chatStore.loadMoreMessages(chatData.value._id, oldestMessageId);
          
          // Сохраняем текущую позицию прокрутки
          const { scrollHeight, scrollTop } = messagesContainer.value;
          const currentPosition = scrollHeight - scrollTop;
          
          // Ждем обновления DOM
          await nextTick();
          
          // Восстанавливаем позицию прокрутки относительно нового содержимого
          if (messagesContainer.value) {
            messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight - currentPosition;
          }
        }
      } catch (error) {
        // Показываем уведомление об ошибке
        useNotification('Ошибка при загрузке старых сообщений', 'error');
      } finally {
        chatStore.loadingMore = false;
      }
    }
  }, { threshold: 0.1 });
  
  // Начинаем наблюдение за триггером загрузки
  if (loadingTrigger.value) {
    observer.value.observe(loadingTrigger.value);
  }
};

// Загрузка дополнительных сообщений
const loadMoreMessages = async () => {
  if (chatStore.loadingMore || !chatData.value || !chatStore.pagination.hasMore) return;
  
  // Запоминаем позицию прокрутки перед загрузкой
  const container = messagesContainer.value;
  const scrollHeight = container.scrollHeight;
  const scrollTop = container.scrollTop;
  
  await chatStore.loadMoreMessages();
  
  // Восстанавливаем позицию прокрутки после загрузки
  nextTick(() => {
    if (container) {
      container.scrollTop = container.scrollHeight - scrollHeight + scrollTop;
    }
  });
};

// Прокрутка к последнему сообщению
const scrollToBottom = (smooth = false) => {
  if (messagesContainer.value) {
    // Используем плавную прокрутку для лучшего UX
    messagesContainer.value.scrollTo({
      top: messagesContainer.value.scrollHeight,
      behavior: smooth ? 'smooth' : 'auto' // Используем 'smooth' для плавной прокрутки при необходимости
    });
  }
};

// Отправка сообщения
const sendMessage = async () => {
  // Проверяем, есть ли текст сообщения
  if (!messageText.value.trim()) return;
  
  // Если редактируем сообщение, сохраняем изменения
  if (isEditingMessage.value && selectedMessage.value) {
    await saveEditedMessage();
    return;
  }
  
  // Иначе отправляем новое сообщение
  try {
    // Отправляем сообщение через хранилище чата
    await chatStore.sendMessage({
      chatId: chatData.value._id,
      text: messageText.value.trim()
    });
    
    // Очищаем поле ввода
    messageText.value = '';
    
    // Сбрасываем высоту textarea
    adjustTextareaHeight();
    
    // Прокручиваем чат вниз
    nextTick(() => {
      scrollToBottom(true);
    });
  } catch (error) {
    console.error('Ошибка при отправке сообщения:', error);
  }
};

// Форматирование даты сообщения
const formatDate = (timestamp) => {
  if (!timestamp) return '';
  
  const date = new Date(timestamp);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date >= today) {
    return 'Сегодня';
  } else if (date >= yesterday) {
    return 'Вчера';
  } else {
    return date.toLocaleDateString('ru-RU', {
      day: 'numeric',
      month: 'long'
    });
  }
};

// Форматирование времени сообщения
const formatTime = (timestamp) => {
  if (!timestamp) return '';
  
  const date = new Date(timestamp);
  return date.toLocaleTimeString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit'
  });
};

// Форматирование даты заголовка
const formatDateHeader = (dateKey) => {
  const [year, month, day] = dateKey.split('-').map(Number);
  const date = new Date(year, month, day);
  
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date.getFullYear() === today.getFullYear() && 
      date.getMonth() === today.getMonth() && 
      date.getDate() === today.getDate()) {
    return 'Сегодня';
  } else if (date.getFullYear() === yesterday.getFullYear() && 
             date.getMonth() === yesterday.getMonth() && 
             date.getDate() === yesterday.getDate()) {
    return 'Вчера';
  } else {
    const monthNames = [
      'января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 
      'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
    ];
    return `${day} ${monthNames[month]}`;
  }
};

// Проверка, нужно ли показывать заголовок с датой
const shouldShowDateHeader = (message, index) => {
  if (index === 0) return true;
  
  const currentDate = new Date(message.timestamp);
  const previousDate = new Date(visibleMessages.value[index - 1].timestamp);
  
  return (
    currentDate.getDate() !== previousDate.getDate() ||
    currentDate.getMonth() !== previousDate.getMonth() ||
    currentDate.getFullYear() !== previousDate.getFullYear()
  );
};

// Обработка воспроизведения видео
const handleVideoPlay = (messageId) => {
  const message = messages.value.find(m => m._id === messageId);
  if (!message) return;
  
  playbackControlData.value = {
    isActive: true,
    username: message.sender?.name || 'Пользователь',
    speed: 1,
    videoId: messageId
  };
};

// Изменение скорости воспроизведения
const changePlaybackSpeed = (speed) => {
  playbackControlData.value.speed = speed;
  
  // Найти все видео и установить скорость
  const videos = document.querySelectorAll('video');
  videos.forEach(video => {
    video.playbackRate = speed;
  });
};

// Остановка видео
const stopVideo = () => {
  playbackControlData.value.isActive = false;
  
  // Найти все видео и остановить их
  const videos = document.querySelectorAll('video');
  videos.forEach(video => {
    video.pause();
  });
};

// Проверка, является ли сообщение собственным
const isOwnMessage = (message) => {
  // Проверяем ID отправителя
  const senderIdMatch = message.sender?._id === authStore.user?._id;
  
  // Проверяем email отправителя как дополнительный идентификатор
  const emailMatch = message.sender?.email === authStore.user?.email;
  
  // Если совпадает ID или email, считаем сообщение своим
  return senderIdMatch || emailMatch;
};

// Получение инициалов из имени
const getInitials = (name) => {
  if (!name) return '?';
  return name
    .split(' ')
    .map(word => word.charAt(0).toUpperCase())
    .slice(0, 2)
    .join('');
};

// Обработчики событий модальных окон
const onParticipantsUpdated = () => {
  // Обновление уже произошло в хранилище
};

const onChatLeft = () => {
  // Обработка выхода из чата (чат уже удален из хранилища)
};

// Функции для управления контекстным меню сообщений
const showContextMenu = (event, message) => {
  // Предотвращаем стандартное контекстное меню браузера
  event.preventDefault();
  
  // Устанавливаем позицию меню
  contextMenuPosition.value = {
    x: event.clientX,
    y: event.clientY
  };
  
  // Устанавливаем выбранное сообщение
  selectedMessage.value = message;
  
  // Показываем меню
  contextMenuVisible.value = true;
};

const hideContextMenu = () => {
  contextMenuVisible.value = false;
};

// Функции для редактирования сообщений
const startEditingMessage = (message) => {
  // Проверяем, что сообщение существует и принадлежит текущему пользователю
  if (!message || !isOwnMessage(message)) return;
  
  // Сохраняем оригинальный текст сообщения
  originalMessageText.value = message.text;
  
  // Устанавливаем текст для редактирования
  editingMessageText.value = message.text;
  messageText.value = message.text;
  
  // Устанавливаем выбранное сообщение
  selectedMessage.value = message;
  
  // Включаем режим редактирования
  isEditingMessage.value = true;
  
  // Фокусируемся на поле ввода
  nextTick(() => {
    if (messageInput.value) {
      messageInput.value.focus();
    }
  });
};

const cancelEditingMessage = () => {
  // Сбрасываем состояние редактирования
  isEditingMessage.value = false;
  selectedMessage.value = null;
  messageText.value = '';
  editingMessageText.value = '';
  originalMessageText.value = '';
};

const saveEditedMessage = async () => {
  // Проверяем, что сообщение выбрано и текст изменился
  if (!selectedMessage.value || messageText.value.trim() === originalMessageText.value) {
    cancelEditingMessage();
    return;
  }
  
  try {
    // Обновляем сообщение через хранилище чата
    await chatStore.updateMessage({
      messageId: selectedMessage.value._id,
      chatId: chatData.value._id,
      text: messageText.value.trim()
    });
    
    // Сбрасываем состояние редактирования
    cancelEditingMessage();
  } catch (error) {
    console.error('Ошибка при обновлении сообщения:', error);
  }
};

const deleteMessage = async (message) => {
  // Проверяем, что сообщение существует и принадлежит текущему пользователю
  if (!message || !isOwnMessage(message)) return;
  
  try {
    // Удаляем сообщение через хранилище чата
    await chatStore.deleteMessage({
      messageId: message._id,
      chatId: chatData.value._id
    });
  } catch (error) {
    console.error('Ошибка при удалении сообщения:', error);
  }
};

// Обработка клика на сообщении
const handleMessageClick = (event, message) => {
  // Если клик на сообщении на мобильном устройстве, показываем контекстное меню
  if (isMobile.value) {
    showContextMenu(event, message);
  }
};

// Получаем функцию и состояние переключения боковой панели из app.vue
// Функция для переключения боковой панели на мобильных устройствах
const toggleSidebar = () => {
  // Получаем доступ к глобальному состоянию видимости боковой панели
  const nuxtApp = useNuxtApp();
  
  // Если есть доступ к глобальному состоянию
  if (nuxtApp && nuxtApp.$sidebarVisible !== undefined) {
    nuxtApp.$sidebarVisible.value = !nuxtApp.$sidebarVisible.value;
  } else {
    // Фоллбэк: прямое переключение класса в DOM
    const app = document.querySelector('.app');
    if (app) {
      app.classList.toggle('sidebar-visible');
    }
  }
};
// Получаем доступ к глобальному состоянию
const nuxtApp = useNuxtApp();
const sidebarVisible = ref(false);
const isMobile = ref(false);

// Обновляем состояние при монтировании компонента
onMounted(() => {
  if (nuxtApp.$sidebarVisible) {
    sidebarVisible.value = nuxtApp.$sidebarVisible.value;
    
    // Следим за изменениями глобального состояния
    watch(() => nuxtApp.$sidebarVisible.value, (newValue) => {
      sidebarVisible.value = newValue;
    });
  }
  
  // Проверяем размер экрана
  isMobile.value = window.innerWidth <= 859;
  window.addEventListener('resize', () => {
    isMobile.value = window.innerWidth <= 859;
  });
});
// Функция для показа боковой панели
const showSidebar = () => {
  if (nuxtApp.$sidebarVisible) {
    nuxtApp.$sidebarVisible.value = true;
  } else {
    const app = document.querySelector('.app');
    if (app) {
      app.classList.add('sidebar-visible');
    }
  }
};

// Функция для выбора чата на мобильных устройствах
const selectChatMobile = () => {
  if (isMobile.value) {
    // Скрываем боковую панель на мобильных устройствах
    const nuxtApp = useNuxtApp();
    if (nuxtApp.$sidebarVisible) {
      nuxtApp.$sidebarVisible.value = false;
    }
  }
};

// Определяем checkMobile в глобальной области видимости компонента
const checkMobile = () => {
  if (isMobile && typeof isMobile.value !== 'undefined') {
    isMobile.value = window.innerWidth <= 859;
  }
};

// Жизненный цикл компонента
onMounted(() => {
  // Проверяем размер экрана при загрузке
  checkMobile();
  window.addEventListener('resize', checkMobile);
  
  // Инициализируем бесконечную прокрутку
  setupInfiniteScroll();
  
  // Инициализируем видимые сообщения с пустым массивом, если сообщения еще не загружены
  visibleMessages.value = Array.isArray(messages.value) ? messages.value : [];
  
  // Инициализируем WebSocket слушатели для реального времени
  const { $socket, $socketConnect } = useNuxtApp();
  
  // Если сокет не подключен, выполняем подключение
  if ($socket && !$socket.connected) {
    $socketConnect();
    
    // Даем немного времени на установку соединения
    setTimeout(() => {
      // Настройка WebSocket слушателей
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 500);
  } else {
    // Настройка WebSocket слушателей
    setupWebSocketListeners();
    
    // Если есть активный чат, подключаемся к его комнате
    if (chatData.value && chatData.value._id) {
      const { $socketJoinChat } = useNuxtApp();
      $socketJoinChat(chatData.value._id);
    }
  }
});

onUnmounted(() => {
  if (observer.value) {
    observer.value.disconnect();
  }
  
  // Отписываемся от WebSocket событий при уничтожении компонента
  const { $socket } = useNuxtApp();
  if ($socket) {
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    
    // Если есть активный чат, покидаем его комнату
    if (chatData.value && chatData.value._id) {
      const { $socketLeaveChat } = useNuxtApp();
      $socketLeaveChat(chatData.value._id);
    }
  }
  
  // Удаляем обработчик изменения размера окна
  window.removeEventListener('resize', checkMobile);
});

// Следим за изменением активного чата
watch(() => chatStore.activeChat, (newChat, oldChat) => {
  // Если был активен другой чат, покидаем его комнату
  if (oldChat && oldChat._id) {
    const { $socketLeaveChat } = useNuxtApp();
    $socketLeaveChat(oldChat._id);
  }
  
  // Если выбран новый чат, подключаемся к его комнате
  if (newChat && newChat._id) {
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(newChat._id);
    
    // Обновляем WebSocket слушатели
    setupWebSocketListeners();
  }
  
  nextTick(() => {
    setupInfiniteScroll();
    scrollToBottom(true);
    
    // На мобильных устройствах скрываем sidebar при выборе чата
    if (isMobile.value) {
  selectChatMobile();
}
  });
});

// Следим за изменениями в сообщениях
watch(messages, (newMessages) => {
  if (Array.isArray(newMessages)) {
    visibleMessages.value = newMessages;
    // Используем requestAnimationFrame для оптимизации производительности
    requestAnimationFrame(() => {
      nextTick(() => {
        scrollToBottom(true);
      });
    });
  }
}, { deep: true });

// Добавление новой строки при нажатии Shift+Enter
// Обработка нажатия клавиши Enter
const handleEnterKey = () => {
  // На мобильных устройствах Enter добавляет новую строку
  if (isMobile.value) {
    addNewLine();
  } else {
    // На десктопе Enter отправляет сообщение
    sendMessage();
  }
};

// Добавление новой строки при нажатии Shift+Enter
const addNewLine = () => {
  messageText.value += '\n';
  nextTick(() => {
    adjustTextareaHeight();
  });
};

// Автоматическая адаптация высоты textarea при вводе
const adjustTextareaHeight = () => {
  if (!messageInput.value || !inputArea.value || !messagesContainer.value) return;

  // Сначала сбрасываем высоту, чтобы получить правильный scrollHeight
  messageInput.value.style.height = 'auto';

  // Ограничиваем максимальную высоту
  const maxHeight = 150;
  const minHeight = 44; // Минимальная высота равна высоте кнопки

  // Вычисляем новую высоту на основе содержимого
  const scrollHeight = messageInput.value.scrollHeight;
  const newHeight = Math.min(maxHeight, Math.max(minHeight, scrollHeight));

  // Устанавливаем новую высоту textarea
  messageInput.value.style.height = `${newHeight}px`;

  // Получаем высоту .input_area (включая padding и возможный индикатор редактирования)
  const inputAreaHeight = inputArea.value.offsetHeight;

  // Получаем высоту .page_header
  const headerHeight = pageHeader.value ? pageHeader.value.offsetHeight : 60; // Фоллбэк на 60px

  // Обновляем max-height для .messages_container
  messagesContainer.value.style.maxHeight = `calc(100vh - ${headerHeight}px - ${inputAreaHeight}px)`;
};

// Функция отладки WebSocket
const debugWebSocket = () => {
  const { $socket, $socketConnect } = useNuxtApp();
  
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // alert(`WebSocket: ${$socket.connected ? 'Подключен' : 'Отключен'}`);
  
  if (!$socket.connected) {
    // alert('Попытка переподключения WebSocket...');
    
    // Перед подключением удаляем все обработчики и перенастраиваем их
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    $socket.off('joined-chat');
    
    // Пробуем переключиться на polling, если есть проблемы с websocket
    $socket.io.opts.transports = ['polling', 'websocket'];
    
    // Переподключаемся
    $socketConnect();
    
    // Перенастраиваем слушатели после переподключения
    setTimeout(() => {
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 1000);
  } else if (chatData.value && chatData.value._id) {
    // alert(`Переподключились к чату: ${chatData.value.name}`);
    
    // Проверяем подключение к комнате чата
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(chatData.value._id);
    
    // Перенастраиваем слушатели
    setupWebSocketListeners();
    
    // Пробуем перезагрузить сообщения чата
    chatStore.fetchMessages(chatData.value._id);
  }
};

// Настройка WebSocket слушателей
const setupWebSocketListeners = () => {
  // Получаем доступ к WebSocket
  const { $socket, $socketConnect, $socketJoinChat } = useNuxtApp();
  
  // Проверяем, что у нас есть доступ к сокету
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // Убедимся, что WebSocket подключен
  ifartement: true
});

// Добавление новой строки при нажатии Shift+Enter
const addNewLine = () => {
  messageText.value += '\n';
  nextTick(() => {
    adjustTextareaHeight();
  });
};

// Автоматическая адаптация высоты textarea при вводе
const adjustTextareaHeight = () => {
  if (!messageInput.value || !inputArea.value || !messagesContainer.value) return;

  // Сначала сбрасываем высоту, чтобы получить правильный scrollHeight
  messageInput.value.style.height = 'auto';

  // Ограничиваем максимальную высоту
  const maxHeight = 150;
  const minHeight = 44; // Минимальная высота равна высоте кнопки

  // Вычисляем новую высоту на основе содержимого
  const scrollHeight = messageInput.value.scrollHeight;
  const newHeight = Math.min(maxHeight, Math.max(minHeight, scrollHeight));

  // Устанавливаем новую высоту textarea
  messageInput.value.style.height = `${newHeight}px`;

  // Получаем высоту .input_area (включая padding и возможный индикатор редактирования)
  const inputAreaHeight = inputArea.value.offsetHeight;

  // Получаем высоту .page_header
  const headerHeight = pageHeader.value ? pageHeader.value.offsetHeight : 60; // Фоллбэк на 60px

  // Обновляем max-height для .messages_container
  messagesContainer.value.style.maxHeight = `calc(100vh - ${headerHeight}px - ${inputAreaHeight}px)`;
};

// Функция отладки WebSocket
const debugWebSocket = () => {
  const { $socket, $socketConnect } = useNuxtApp();
  
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // alert(`WebSocket: ${$socket.connected ? 'Подключен' : 'Отключен'}`);
  
  if (!$socket.connected) {
    // alert('Попытка переподключения WebSocket...');
    
    // Перед подключением удаляем все обработчики и перенастраиваем их
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    $socket.off('joined-chat');
    
    // Пробуем переключиться на polling, если есть проблемы с websocket
    $socket.io.opts.transports = ['polling', 'websocket'];
    
    // Переподключаемся
    $socketConnect();
    
    // Перенастраиваем слушатели после переподключения
    setTimeout(() => {
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 1000);
  } else if (chatData.value && chatData.value._id) {
    // alert(`Переподключились к чату: ${chatData.value.name}`);
    
    // Проверяем подключение к комнате чата
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(chatData.value._id);
    
    // Перенастраиваем слушатели
    setupWebSocketListeners();
    
    // Пробуем перезагрузить сообщения чата
    chatStore.fetchMessages(chatData.value._id);
  }
};

// Настройка WebSocket слушателей
const setupWebSocketListeners = () => {
  // Получаем доступ к WebSocket
  const { $socket, $socketConnect, $socketJoinChat } = useNuxtApp();
  
  // Проверяем, что у нас есть доступ к сокету
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // Убедимся, что WebSocket подключен
  if (!$socket.connected) {
    $socketConnect();
  } else {
    // alert('WebSocket уже подключен');
    
    // Если сокет уже подключен и есть активный чат, сразу подключаемся к комнате
    if (chatData.value && chatData.value._id) {
      $socketJoinChat(chatData.value._id);
    }
  }
  
  // Удаляем существующие обработчики, чтобы избежать дублирования
  $socket.off('connect');
  $socket.off('new-message');
  $socket.off('messages-read');
  $socket.off('joined-chat');
  
  // Подписываемся на события WebSocket
  $socket.on('connect', () => {
    // alert('WebSocket подключен успешно');
    
    // Если есть активный чат, подключаемся к его комнате
    if (chatData.value && chatData.value._id) {
      $socketJoinChat(chatData.value._id);
    }
  });
  
  // Обработчик успешного подключения к комнате чата
  $socket.on('joined-chat', ({ chatId, success }) => {
    // alert(`Подключение к комнате чата ${chatId}: ${success ? 'успешно' : 'не удалось'}`);
  });
  
  // Слушаем новые сообщения
  $socket.on('new-message', ({ message, chatId }) => {
    // alert('Получено новое сообщение через WebSocket:', message, 'для чата:', chatId);
    
    // Если сообщение для текущего чата, добавляем его в список
    if (chatData.value && chatData.value._id === chatId) {
      // Проверяем, не добавлено ли уже это сообщение (избегаем дубликатов)
      const isDuplicate = chatStore.messages.some(m => m._id === message._id);
      if (isDuplicate) {
        // alert('Дублирующееся сообщение проигнорировано:', message._id);
        return;
      }
      
      // alert('Добавляем новое сообщение в чат:', message);
      
      // Для изображений, предварительно загружаем их перед добавлением в список сообщений
      if (message.media_type === 'image' && message.file) {
        // Инициализируем флаг загрузки изображения
        message.imageLoaded = false;
        
        // Добавляем сообщение сразу, чтобы показать загрузчик
        chatStore.messages.push({...message});
        
        const img = new Image();
        img.onload = () => {
          // Находим сообщение в массиве и обновляем его статус
          const msgIndex = chatStore.messages.findIndex(m => m._id === message._id);
          if (msgIndex !== -1) {
            // Устанавливаем флаг, что изображение загружено
            chatStore.messages[msgIndex].imageLoaded = true;
          }
          
          // Прокручиваем к новому сообщению, если пользователь находится внизу чата
          if (isAtBottom.value) {
            nextTick(() => {
              scrollToBottom(true);
            });
          } else {
            // Показываем индикатор нового сообщения
            showNewMessageIndicator.value = true;
          }
        };
        img.onerror = () => {
          // alert('Ошибка загрузки изображения:', message.file);
          
          // Находим сообщение в массиве и обновляем его статус
          const msgIndex = chatStore.messages.findIndex(m => m._id === message._id);
          if (msgIndex !== -1) {
            // Помечаем как загруженное, чтобы не показывать бесконечную загрузку
            chatStore.messages[msgIndex].imageLoaded = true;
          }
          
          if (isAtBottom.value) {
            nextTick(() => {
              scrollToBottom(true);
            });
          } else {
            showNewMessageIndicator.value = true;
          }
        };
        img.src = message.file;
      } else {
        // Для не-изображений добавляем сообщение сразу
        chatStore.messages.push({...message});
        
        // Прокручиваем к новому сообщению, если пользователь находится внизу чата
        if (isAtBottom.value) {
          nextTick(() => {
            scrollToBottom(true);
          });
        } else {
          // Показываем индикатор нового сообщения
          showNewMessageIndicator.value = true;
        }
        
        // Прокручиваем к новому сообщению, если пользователь находится внизу чата
        if (isAtBottom.value) {
          nextTick(() => {
            scrollToBottom(true);
          });
        } else {
          // Показываем индикатор нового сообщения
          showNewMessageIndicator.value = true;
        }
      }
      
      // Если сообщение не от текущего пользователя, отмечаем его как прочитанное
      if (message.sender && message.sender._id !== authStore.user._id) {
        chatStore.markMessagesAsRead(chatId);
      }
    }
  });
  
  // Слушаем прочтение сообщений
  $socket.on('messages-read', ({ chatId, userId }) => {
    // alert('Сообщения отмечены как прочитанные:', { chatId, userId });
    
    // Обновляем статус прочтения сообщений в текущем чате
    if (chatData.value && chatData.value._id === chatId) {
      chatStore.updateMessagesReadStatus(chatId, userId);
    }
  });
};

const openChatSettings = () => {
  showChatSettingsModal.value = true;
};
</script>

<style lang="sass">
@import '@variables'

.chat-page
  height: 100vh
  width: 100%
  display: flex
  flex-direction: column
  position: relative
  
  .page_header
    padding: 10px 
    background-color: $header-bg
    display: flex
    align-items: center
    justify-content: space-between
    border-bottom: 1px solid rgba(255, 255, 255, 0.1)
    
    // Кнопка переключения боковой панели
    .toggle-sidebar-btn
      display: none
      background: transparent
      border: none
      color: $white
      font-size: 20px
      cursor: pointer
      padding: 5px 10px
      margin-right: 10px
      transition: all 0.2s ease

      &__icon
        transform: rotate(90deg)
      
      &:hover
        color: rgba(255, 255, 255, 0.8)
      
      @include tablet
        display: block
    
    .content
      display: flex
      align-items: center
      
      &__img
        width: 50px
        height: 50px
        border-radius: 50%
        margin-right: 10px
        background-color: $purple
        background-size: cover
        background-position: center
        display: flex
        align-items: center
        justify-content: center
        
        .initials
          font-size: 18px
          font-weight: bold
          color: $white
        
      &__textblock
        display: flex
        flex-direction: column
        
        .text
          color: $white
          
          &.bold
            font-weight: bold
            font-size: 16px
          
          &.member
            font-size: 12px
            color: rgba(255, 255, 255, 0.7)
    
    .chat-actions
      margin-left: auto
      display: flex
      gap: 10px
      
      .action-btn
        background-color: rgba(255, 255, 255, 0.1)
        color: $white
        border: none
        border-radius: 50%
        width: 36px
        height: 36px
        display: flex
        align-items: center
        justify-content: center
        cursor: pointer
        
        &:hover
          background-color: rgba(255, 255, 255, 0.2)
        
        .icon
          font-size: 18px
  
  .no-chat-selected
    flex: 1
    display: flex
    align-items: center
綜 justify-content: center
    color: rgba(255, 255, 255, 0.5)
    font-size: 18px
  
  .chat-content
    display: flex
    flex-direction: column
    height: 100%
    width: 100%
    overflow: hidden
  
  .messages_container
    flex: 1 1 auto
    overflow-y: auto
    padding: 0px 20px
    display: flex
    width: 100%
    flex-direction: column
    position: relative
    z-index: 1
    @include custom-scrollbar
    >*
      max-width: 700px;
      width: 100%;
      align-self: center;
    
    .loading-trigger
      height: 20px
      margin-bottom: 10px
    
    .loading-indicator 
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      color: $white;
      
      &.loading-more 
        margin-bottom: 10px;
        opacity: 0.7;
      
      
      &.initial-loading 
        height: 100px;
        margin: auto;
      
      
      .spinner 
        width: 20px
        height: 20px
        border: 2px solid rgba(255, 255, 255, 0.3)
        border-radius: 50%
        border-top-color: $white
        animation: spin 1s ease-in-out infinite
        margin-right: 10px
        will-change: transform; // Оптимизация для анимации
    
    .empty-chat
      text-align: center
      padding: 30px
      color: rgba(255, 255, 255, 0.5)
    
    .date-header
      text-align: center
      margin: 15px 0
      
      span
        background-color: rgba(255, 255, 255, 0.1)
        color: $white
        padding: 5px 10px
        border-radius: 10px
        font-size: 12px
    
    .service_message
      text-align: center
      margin: 10px 0
      color: rgba(255, 255, 255, 0.7)
      font-size: 12px
      
      .time
        margin-top: 5px
        font-size: 10px
        opacity: 0.7
    
    .message_wrap
      margin-bottom: 10px
      width: 100%
      display: flex
      flex-direction: column
      
      .message
        display: flex
        flex-direction: column
        max-width: 70%
        margin-bottom: 5px
        
        &.own
          align-self: flex-end
          
          .message__content
            background-color: $purple
            border-radius: 15px 15px 0 15px
            margin-left: auto
        
        &.other
          align-self: flex-start
          
          .message__content
            background-color: $header-bg
            border-radius: 15px 15px 15px 0
        
        &__content
          padding: 10px 15px
          color: $white
          word-break: break-word
        
        &__from
          color: rgba(255, 255, 255, 0.8)
          font-weight: bold
          margin-bottom: 5px
          font-size: 14px
        
        &__text
          color: $white
          
          pre
            font-family: inherit
            margin: 0
            white-space: pre-wrap
            word-break: break-word
        
        &__time
          text-align: right
          font-size: 10px
          color: rgba(255, 255, 255, 0.6)
          margin-top: 5px
        
        .video-container, .image-container
          margin: 5px 0
          position: relative
          
          .video-message-player, .message-image
            max-width: 100%
            border-radius: 8px
            max-height: 300px
            opacity: 0
            transition: opacity 0.3s ease-in-out
            
            &.loaded
              opacity: 1
          
          .image-loading
            position: absolute
            top: 0
            left: 0
            width: 100%
            height: 100%
            display: flex
            align-items: center
            justify-content: center
            background-color: rgba(0, 0, 0, 0.1)
            z-index: 2
            border-radius: 8px
            
            .loading-spinner
              width: 30px
              height: 30px
              border: 3px solid rgba(255, 255, 255, 0.3)
              border-radius: 50%
              border-top-color: $purple
              animation: spin 1s ease-in-out infinite
              margin: 0 auto
              background-color: transparent
              will-change: transform; // Оптимизация для анимации
    
        .sticker-container
          .message-sticker
            max-width: 120px
            max-height: 120px
        
        .file-container
          margin: 5px 0
          
          .file-link
            display: flex
            align-items: center
            color: $white
            text-decoration: none
            background-color: rgba(255, 255, 255, 0.1)
            padding: 8px 12px
            border-radius: 8px
            
            &:hover
              background-color: rgba(255, 255, 255, 0.2)
            
            .file-icon
              margin-right: 8px
              font-size: 16px
  
  .input_area
    align-self: center
    max-width: 700px
    width: 100%
    padding: 15px
    flex: 0 0 auto
    position: relative
    z-index: 2
    
    .editing-indicator
      display: flex
      align-items: center
      justify-content: space-between
      padding: 5px 10px
      background-color: rgba(255, 255, 255, 0.1)
      border-radius: 10px
      margin-bottom: 10px
      
      .editing-text
        color: $white
        font-size: 14px
        
        i
          margin-right: 5px
      
      .cancel-btn
        background-color: transparent
        border: none
        color: $white
        font-size: 16px
        cursor: pointer
        
        &:hover
          color: rgba(255, 255, 255, 0.8)
    
    .input_container
      display: flex
      align-items: flex-end
      gap: 10px
      position: relative
      
      .message_input
        flex: 1
        // Дополнительные стили, основные уже в классе inp--textarea
      
      .button_container
        width: 44px
        height: 44px
        
        .send_button
          background-color: $purple
          color: $white
          border: none
          border-radius: 50%
          width: 44px
          height: 44px
          display: flex
          align-items: center
          justify-content: center
          cursor: pointer
          
          &:hover
            background-color: darken($purple, 10%)
          
          &:disabled
            opacity: 0.5
            cursor: not-allowed
          
          i
            font-size: 18px

  
@keyframes spin
  0%
    transform: rotate(0deg)
  100%
    transform: rotate(360deg)


.scroll-btn-enter-active, .scroll-btn-leave-active
  transition: opacity 0.5s ease, transform 0.5s ease

.scroll-btn-enter-from, .scroll-btn-leave-to
  opacity: 0
  transform: translateY(20px)


@include mobile
  .chat-page
    display: flex
    flex-direction: column
    height: 100vh
    overflow: hidden
    
    .chat-content
      display: flex
      flex-direction: column
      height: 100%
      width: 100%
      overflow: hidden
      
    .page_header
      flex: 0 0 auto
      
    .messages_container
      flex: 1 1 auto
      overflow-y: auto
      position: relative
      z-index: 1
      min-height: 0 // Предотвращает переполнение
      
    .input_area
      flex: 0 0 auto
      width: 100%
      z-index: 2
      padding: 10px
      position: relative
      
    .message_wrap
      .message
        max-width: 90%

.image-container
  position: relative
  margin: 5px 0
  max-width: 300px
  
  .image-loading
    position: absolute
    top: 0
    left: 0
    width: 100%
    height: 100%
    display: flex
    align-items: center
    justify-content: center
    background-color: rgba(0, 0, 0, 0.2)
    z-index: 2
    border-radius: 8px
    
    .loading-spinner
      width: 30px
      height: 30px
      border: 3px solid rgba(255, 255, 255, 0.3)
      border-radius: 50%
      border-top-color: $purple
      animation: spin 1s ease-in-out infinite
      margin: 0 auto
      background-color: transparent
      will-change: transform; // Оптимизация для анимации
    
  .message-image
    max-width: 100%
    border-radius: 8px
    opacity: 0.7
    transition: opacity 0.3s ease
    
    &.loaded
      opacity: 1
</style><template>
  <div class="chat-page">
    <!-- Если чат не выбран или данные еще не загружены -->
    <div v-if="!chatData || !chatData._id" class="no-chat-selected">
      Выберите чат, чтобы начать общение
    </div>
    
    <!-- Если чат выбран -->
    <div v-else class="chat-content">
      <!-- Шапка чата -->
      <div class="page_header" @click="openChatSettings">
        <!-- Кнопка переключения боковой панели для мобильных устройств -->
        <button class="toggle-sidebar-btn" @click.stop="toggleSidebar">
          <IconBottomArrow class="toggle-sidebar-btn__icon" filled />
        </button>
        
        <div class="content">
          <div 
            class="content__img" 
            :style="chatData.avatar ? `background-image: url(${secureUrl(chatData.avatar)})` : ''"
          >
            <div v-if="!chatData.avatar" class="initials">
              {{ getInitials(chatData.name) }}
            </div>
          </div>
          <div class="content__textblock">
            <div class="text bold">{{ chatData.name }}</div>
            <div class="text member">{{ chatData.participants?.length || 0 }} участник(ов)</div>
          </div>
        </div>
        
        <div class="chat-actions">
        </div>
      </div>
      
      <!-- Контейнер сообщений -->
      <div class="messages_container" ref="messagesContainer" @scroll="checkIfAtBottom">        
        <!-- Индикатор загрузки дополнительных сообщений -->
        <div v-if="chatStore.loadingMore" class="loading-indicator loading-more">
          <div class="spinner"></div>
          <span>Загрузка старых сообщений...</span>
        </div>
        
        <!-- Индикатор первичной загрузки -->
        <div v-if="chatStore.loading && !visibleMessages.length" class="loading-indicator initial-loading">
          <div class="spinner"></div>
          <span>Загрузка сообщений...</span>
        </div>
        
        <!-- Если сообщений нет -->
        <div v-if="!chatStore.loading && messages.length === 0" class="empty-chat">
          Нет сообщений. Начните общение!
        </div>
        
        <!-- Сообщения, сгруппированные по датам -->
        <div v-for="group in groupedMessages" :key="group.date">
          <!-- Заголовок с датой -->
          <div class="date-header">
            <span>{{ formatDate(group.date) }}</span>
          </div>
          
          <!-- Сообщения группы -->
          <div v-for="message in group.messages" :key="message._id" class="message_wrap">
            <!-- Service message -->
            <div v-if="message.type === 'service'" class="service_message">
              <div>{{ message.text }}</div>
              <div class="time">{{ formatTime(message.createdAt || message.timestamp) }}</div>
            </div>
            
            <!-- Regular message -->
            <div 
              v-else 
              class="message" 
              :class="isOwnMessage(message) ? 'own' : 'other'"
              @contextmenu.prevent="showContextMenu($event, message)"
              @click="handleMessageClick($event, message)"
            >
              <!-- Имя отправителя (для групповых чатов) -->
              <div 
                v-if="!isOwnMessage(message) && chatData.participants?.length > 2" 
                class="message__from"
              >
                {{ message.sender?.name }}
              </div>
              
              <!-- Контент сообщения -->
              <div class="message__content">
                <!-- Имя отправителя (для групповых чатов) -->
                <div 
                  v-if="!isOwnMessage(message) && chatData.participants?.length > 2 && message.media_type !== 'none'" 
                  class="message__from"
                >
                  {{ message.sender?.name }}
                </div>
                
                <!-- Message content based on type -->
                <div v-if="message.media_type === 'none'" class="message__text">
                  <pre>{{ message.text }}</pre>
                </div>
                
                <div v-else-if="message.media_type === 'image'" class="image-container">
                  <div v-if="!message.imageLoaded" class="image-loading">
                    <div class="loading-spinner"></div>
                  </div>
                  <img 
                    :src="message.file" 
                    alt="Image" 
                    class="message-image" 
                    @load="message.imageLoaded = true"
                    :class="{ 'loaded': message.imageLoaded }"
                  />
                </div>
                
                <div v-else-if="message.media_type === 'video'" class="video-container">
                  <video 
                    :id="message._id" 
                    class="video-message-player" 
                    controls 
                    :src="message.file"
                  ></video>
                </div>
                
                <div v-else-if="message.media_type === 'sticker'" class="sticker-container">
                  <img :src="message.file" alt="Sticker" class="message-sticker" />
                </div>
                
                <div v-else-if="message.media_type === 'file'" class="file-container">
                  <a :href="message.file" target="_blank" class="file-link">
                    <i class="fas fa-file file-icon"></i>
                    {{ message.fileName || 'Файл' }}
                  </a>
                </div>
                
                <div class="message__time">
                  {{ formatTime(message.createdAt || message.timestamp) }}
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Индикатор новых сообщений -->
        <transition name="scroll-btn">
          <ChatNewMessagesButton 
            v-if="!isAtBottom && !chatStore.loadingMore && messages.length > 0" 
            @click="scrollToNewMessages" 
          />
        </transition>
      </div>
      
      <!-- Input area -->
      <div class="input_area" ref="inputArea">
        <!-- Индикатор редактирования сообщения -->
        <div v-if="isEditingMessage" class="editing-indicator">
          <div class="editing-text">
            <i class="fas fa-edit"></i> Редактирование: {{ originalMessageText.length > 30 ? originalMessageText.substring(0, 30) + '...' : originalMessageText }}
          </div>
          <button class="cancel-btn" @click="cancelEditingMessage">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="input_container" ref="inputContainer">
          <textarea 
            v-model="messageText" 
            class="inp inp--textarea message_input" 
            placeholder="Введите сообщение..." 
            @keydown.enter.exact.prevent="handleEnterKey"
            @keydown.shift.enter.prevent="addNewLine"
            @input="adjustTextareaHeight"
            ref="messageInput"
            rows="1"
          ></textarea>
          <div class="button_container">
            <button 
              type="button" 
              class="send_button"
              :disabled="!messageText.trim()"
              @click="sendMessage"
            >
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <ChatSettingsModal 
    v-if="showChatSettingsModal" 
    :is-open="showChatSettingsModal" 
    :chat-data="chatData" 
    :is-new-chat="false" 
    @close="showChatSettingsModal = false" 
    @saved="onChatUpdated" 
  />
  <ChatMessageContextMenu 
    v-if="contextMenuVisible" 
    :is-visible="contextMenuVisible"
    :position="contextMenuPosition" 
    :message="selectedMessage"
    @close="hideContextMenu"
    @edit="startEditingMessage"
    @delete="deleteMessage"
  />
</template>

<script setup>
import { useChatStore } from '~/stores/chat';
import { useAuthStore } from '~/stores/auth';
import { secureUrl } from '~/utils/secureUrl';

// Хранилища
const chatStore = useChatStore();
const authStore = useAuthStore();

// Данные чата и сообщений
const chatData = computed(() => {
  return chatStore.activeChat;
});

const messages = computed(() => {
  return chatStore.messages;
});

// Состояние прокрутки чата
const isAtBottom = ref(true);
const messagesContainer = ref(null);
const showNewMessageIndicator = ref(false);

// Ссылки на элементы
const inputArea = ref(null);
const messageInput = ref(null);
const inputContainer = ref(null);
const pageHeader = ref(null);

// Функция для проверки, находится ли пользователь внизу чата
const checkIfAtBottom = () => {
  if (!messagesContainer.value) return true;
  
  const container = messagesContainer.value;
  const scrollPosition = container.scrollTop + container.clientHeight;
  const scrollHeight = container.scrollHeight;
  
  // Считаем, что пользователь внизу, если он находится в пределах 100px от нижней границы
  isAtBottom.value = scrollHeight - scrollPosition < 100;
  
  // Если пользователь прокрутил вниз до конца, скрываем индикатор новых сообщений
  if (isAtBottom.value) {
    showNewMessageIndicator.value = false;
  }
  
  return isAtBottom.value;
};

// Функция для прокрутки к новым сообщениям
const scrollToNewMessages = () => {
  scrollToBottom(true);
  showNewMessageIndicator.value = false;
};

// Состояние загрузки
const loading = computed(() => chatStore.loading);

const showChatSettingsModal = ref(false);

// Обработка обновления чата после сохранения в модальном окне
const onChatUpdated = () => {
  // Обновляем данные чата, если необходимо
  if (chatData.value && chatData.value._id) {
    chatStore.setActiveChat(chatData.value._id);
  }
};

// Видимые сообщения (для бесконечной прокрутки)
const visibleMessages = ref([]);
const loadingTrigger = ref(null);
const observer = ref(null);
const messageText = ref('');

// Состояния для контекстного меню сообщений
const contextMenuVisible = ref(false);
const contextMenuPosition = ref({ x: 0, y: 0 });
const selectedMessage = ref(null);

// Состояние редактирования сообщения
const isEditingMessage = ref(false);
const editingMessageText = ref('');
const originalMessageText = ref('');

// Данные для управления воспроизведением видео
const playbackControlData = ref({
  isActive: false,
  username: '',
  speed: 1,
  videoId: null
});

// Группировка сообщений по датам
const groupedMessages = computed(() => {
  // Проверяем, что сообщения существуют
  if (!messages.value || !Array.isArray(messages.value)) {
    return [];
  }
  
  const groups = {};
  messages.value.forEach(message => {
    if (!message) return; // Пропускаем недействительные сообщения
    
    // Безопасно получаем дату
    const timestamp = message.createdAt || message.timestamp;
    if (!timestamp) return; // Пропускаем сообщения без времени
    
    const date = new Date(timestamp);
    const key = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
    if (!groups[key]) {
      groups[key] = {
        date: key,
        messages: []
      };
    }
    groups[key].messages.push(message);
  });
  return Object.values(groups);
});

// Настройка бесконечной прокрутки
const setupInfiniteScroll = () => {
  // Отключаем предыдущий observer, если он существует
  if (observer.value) {
    observer.value.disconnect();
  }
  
  // Создаем новый Intersection Observer для бесконечной прокрутки
  observer.value = new IntersectionObserver(async (entries) => {
    const entry = entries[0];
    
    // Если триггер виден и есть еще сообщения для загрузки
    if (entry.isIntersecting && chatStore.pagination.hasMore && !chatStore.loadingMore) {
      chatStore.loadingMore = true;
      
      try {
        // Получаем ID самого старого сообщения
        const oldestMessageId = chatStore.pagination.nextCursor;
        
        if (oldestMessageId) {
          // Загружаем более старые сообщения
          await chatStore.loadMoreMessages(chatData.value._id, oldestMessageId);
          
          // Сохраняем текущую позицию прокрутки
          const { scrollHeight, scrollTop } = messagesContainer.value;
          const currentPosition = scrollHeight - scrollTop;
          
          // Ждем обновления DOM
          await nextTick();
          
          // Восстанавливаем позицию прокрутки относительно нового содержимого
          if (messagesContainer.value) {
            messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight - currentPosition;
          }
        }
      } catch (error) {
        // Показываем уведомление об ошибке
        useNotification('Ошибка при загрузке старых сообщений', 'error');
      } finally {
        chatStore.loadingMore = false;
      }
    }
  }, { threshold: 0.1 });
  
  // Начинаем наблюдение за триггером загрузки
  if (loadingTrigger.value) {
    observer.value.observe(loadingTrigger.value);
  }
};

// Загрузка дополнительных сообщений
const loadMoreMessages = async () => {
  if (chatStore.loadingMore || !chatData.value || !chatStore.pagination.hasMore) return;
  
  // Запоминаем позицию прокрутки перед загрузкой
  const container = messagesContainer.value;
  const scrollHeight = container.scrollHeight;
  const scrollTop = container.scrollTop;
  
  await chatStore.loadMoreMessages();
  
  // Восстанавливаем позицию прокрутки после загрузки
  nextTick(() => {
    if (container) {
      container.scrollTop = container.scrollHeight - scrollHeight + scrollTop;
    }
  });
};

// Прокрутка к последнему сообщению
const scrollToBottom = (smooth = false) => {
  if (messagesContainer.value) {
    // Используем плавную прокрутку для лучшего UX
    messagesContainer.value.scrollTo({
      top: messagesContainer.value.scrollHeight,
      behavior: smooth ? 'smooth' : 'auto' // Используем 'smooth' для плавной прокрутки при необходимости
    });
  }
};

// Отправка сообщения
const sendMessage = async () => {
  // Проверяем, есть ли текст сообщения
  if (!messageText.value.trim()) return;
  
  // Если редактируем сообщение, сохраняем изменения
  if (isEditingMessage.value && selectedMessage.value) {
    await saveEditedMessage();
    return;
  }
  
  // Иначе отправляем новое сообщение
  try {
    // Отправляем сообщение через хранилище чата
    await chatStore.sendMessage({
      chatId: chatData.value._id,
      text: messageText.value.trim()
    });
    
    // Очищаем поле ввода
    messageText.value = '';
    
    // Сбрасываем высоту textarea
    adjustTextareaHeight();
    
    // Прокручиваем чат вниз
    nextTick(() => {
      scrollToBottom(true);
    });
  } catch (error) {
    console.error('Ошибка при отправке сообщения:', error);
  }
};

// Форматирование даты сообщения
const formatDate = (timestamp) => {
  if (!timestamp) return '';
  
  const date = new Date(timestamp);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date >= today) {
    return 'Сегодня';
  } else if (date >= yesterday) {
    return 'Вчера';
  } else {
    return date.toLocaleDateString('ru-RU', {
      day: 'numeric',
      month: 'long'
    });
  }
};

// Форматирование времени сообщения
const formatTime = (timestamp) => {
  if (!timestamp) return '';
  
  const date = new Date(timestamp);
  return date.toLocaleTimeString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit'
  });
};

// Форматирование даты заголовка
const formatDateHeader = (dateKey) => {
  const [year, month, day] = dateKey.split('-').map(Number);
  const date = new Date(year, month, day);
  
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date.getFullYear() === today.getFullYear() && 
      date.getMonth() === today.getMonth() && 
      date.getDate() === today.getDate()) {
    return 'Сегодня';
  } else if (date.getFullYear() === yesterday.getFullYear() && 
             date.getMonth() === yesterday.getMonth() && 
             date.getDate() === yesterday.getDate()) {
    return 'Вчера';
  } else {
    const monthNames = [
      'января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 
      'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря'
    ];
    return `${day} ${monthNames[month]}`;
  }
};

// Проверка, нужно ли показывать заголовок с датой
const shouldShowDateHeader = (message, index) => {
  if (index === 0) return true;
  
  const currentDate = new Date(message.timestamp);
  const previousDate = new Date(visibleMessages.value[index - 1].timestamp);
  
  return (
    currentDate.getDate() !== previousDate.getDate() ||
    currentDate.getMonth() !== previousDate.getMonth() ||
    currentDate.getFullYear() !== previousDate.getFullYear()
  );
};

// Обработка воспроизведения видео
const handleVideoPlay = (messageId) => {
  const message = messages.value.find(m => m._id === messageId);
  if (!message) return;
  
  playbackControlData.value = {
    isActive: true,
    username: message.sender?.name || 'Пользователь',
    speed: 1,
    videoId: messageId
  };
};

// Изменение скорости воспроизведения
const changePlaybackSpeed = (speed) => {
  playbackControlData.value.speed = speed;
  
  // Найти все видео и установить скорость
  const videos = document.querySelectorAll('video');
  videos.forEach(video => {
    video.playbackRate = speed;
  });
};

// Остановка видео
const stopVideo = () => {
  playbackControlData.value.isActive = false;
  
  // Найти все видео и остановить их
  const videos = document.querySelectorAll('video');
  videos.forEach(video => {
    video.pause();
  });
};

// Проверка, является ли сообщение собственным
const isOwnMessage = (message) => {
  // Проверяем ID отправителя
  const senderIdMatch = message.sender?._id === authStore.user?._id;
  
  // Проверяем email отправителя как дополнительный идентификатор
  const emailMatch = message.sender?.email === authStore.user?.email;
  
  // Если совпадает ID или email, считаем сообщение своим
  return senderIdMatch || emailMatch;
};

// Получение инициалов из имени
const getInitials = (name) => {
  if (!name) return '?';
  return name
    .split(' ')
    .map(word => word.charAt(0).toUpperCase())
    .slice(0, 2)
    .join('');
};

// Обработчики событий модальных окон
const onParticipantsUpdated = () => {
  // Обновление уже произошло в хранилище
};

const onChatLeft = () => {
  // Обработка выхода из чата (чат уже удален из хранилища)
};

// Функции для управления контекстным меню сообщений
const showContextMenu = (event, message) => {
  // Предотвращаем стандартное контекстное меню браузера
  event.preventDefault();
  
  // Устанавливаем позицию меню
  contextMenuPosition.value = {
    x: event.clientX,
    y: event.clientY
  };
  
  // Устанавливаем выбранное сообщение
  selectedMessage.value = message;
  
  // Показываем меню
  contextMenuVisible.value = true;
};

const hideContextMenu = () => {
  contextMenuVisible.value = false;
};

// Функции для редактирования сообщений
const startEditingMessage = (message) => {
  // Проверяем, что сообщение существует и принадлежит текущему пользователю
  if (!message || !isOwnMessage(message)) return;
  
  // Сохраняем оригинальный текст сообщения
  originalMessageText.value = message.text;
  
  // Устанавливаем текст для редактирования
  editingMessageText.value = message.text;
  messageText.value = message.text;
  
  // Устанавливаем выбранное сообщение
  selectedMessage.value = message;
  
  // Включаем режим редактирования
  isEditingMessage.value = true;
  
  // Фокусируемся на поле ввода
  nextTick(() => {
    if (messageInput.value) {
      messageInput.value.focus();
    }
  });
};

const cancelEditingMessage = () => {
  // Сбрасываем состояние редактирования
  isEditingMessage.value = false;
  selectedMessage.value = null;
  messageText.value = '';
  editingMessageText.value = '';
  originalMessageText.value = '';
};

const saveEditedMessage = async () => {
  // Проверяем, что сообщение выбрано и текст изменился
  if (!selectedMessage.value || messageText.value.trim() === originalMessageText.value) {
    cancelEditingMessage();
    return;
  }
  
  try {
    // Обновляем сообщение через хранилище чата
    await chatStore.updateMessage({
      messageId: selectedMessage.value._id,
      chatId: chatData.value._id,
      text: messageText.value.trim()
    });
    
    // Сбрасываем состояние редактирования
    cancelEditingMessage();
  } catch (error) {
    console.error('Ошибка при обновлении сообщения:', error);
  }
};

const deleteMessage = async (message) => {
  // Проверяем, что сообщение существует и принадлежит текущему пользователю
  if (!message || !isOwnMessage(message)) return;
  
  try {
    // Удаляем сообщение через хранилище чата
    await chatStore.deleteMessage({
      messageId: message._id,
      chatId: chatData.value._id
    });
  } catch (error) {
    console.error('Ошибка при удалении сообщения:', error);
  }
};

// Обработка клика на сообщении
const handleMessageClick = (event, message) => {
  // Если клик на сообщении на мобильном устройстве, показываем контекстное меню
  if (isMobile.value) {
    showContextMenu(event, message);
  }
};

// Получаем функцию и состояние переключения боковой панели из app.vue
// Функция для переключения боковой панели на мобильных устройствах
const toggleSidebar = () => {
  // Получаем доступ к глобальному состоянию видимости боковой панели
  const nuxtApp = useNuxtApp();
  
  // Если есть доступ к глобальному состоянию
  if (nuxtApp && nuxtApp.$sidebarVisible !== undefined) {
    nuxtApp.$sidebarVisible.value = !nuxtApp.$sidebarVisible.value;
  } else {
    // Фоллбэк: прямое переключение класса в DOM
    const app = document.querySelector('.app');
    if (app) {
      app.classList.toggle('sidebar-visible');
    }
  }
};
// Получаем доступ к глобальному состоянию
const nuxtApp = useNuxtApp();
const sidebarVisible = ref(false);
const isMobile = ref(false);

// Обновляем состояние при монтировании компонента
onMounted(() => {
  if (nuxtApp.$sidebarVisible) {
    sidebarVisible.value = nuxtApp.$sidebarVisible.value;
    
    // Следим за изменениями глобального состояния
    watch(() => nuxtApp.$sidebarVisible.value, (newValue) => {
      sidebarVisible.value = newValue;
    });
  }
  
  // Проверяем размер экрана
  isMobile.value = window.innerWidth <= 859;
  window.addEventListener('resize', () => {
    isMobile.value = window.innerWidth <= 859;
  });
});
// Функция для показа боковой панели
const showSidebar = () => {
  if (nuxtApp.$sidebarVisible) {
    nuxtApp.$sidebarVisible.value = true;
  } else {
    const app = document.querySelector('.app');
    if (app) {
      app.classList.add('sidebar-visible');
    }
  }
};

// Функция для выбора чата на мобильных устройствах
const selectChatMobile = () => {
  if (isMobile.value) {
    // Скрываем боковую панель на мобильных устройствах
    const nuxtApp = useNuxtApp();
    if (nuxtApp.$sidebarVisible) {
      nuxtApp.$sidebarVisible.value = false;
    }
  }
};

// Определяем checkMobile в глобальной области видимости компонента
const checkMobile = () => {
  if (isMobile && typeof isMobile.value !== 'undefined') {
    isMobile.value = window.innerWidth <= 859;
  }
};

// Жизненный цикл компонента
onMounted(() => {
  // Проверяем размер экрана при загрузке
  checkMobile();
  window.addEventListener('resize', checkMobile);
  
  // Инициализируем бесконечную прокрутку
  setupInfiniteScroll();
  
  // Инициализируем видимые сообщения с пустым массивом, если сообщения еще не загружены
  visibleMessages.value = Array.isArray(messages.value) ? messages.value : [];
  
  // Инициализируем WebSocket слушатели для реального времени
  const { $socket, $socketConnect } = useNuxtApp();
  
  // Если сокет не подключен, выполняем подключение
  if ($socket && !$socket.connected) {
    $socketConnect();
    
    // Даем немного времени на установку соединения
    setTimeout(() => {
      // Настройка WebSocket слушателей
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 500);
  } else {
    // Настройка WebSocket слушателей
    setupWebSocketListeners();
    
    // Если есть активный чат, подключаемся к его комнате
    if (chatData.value && chatData.value._id) {
      const { $socketJoinChat } = useNuxtApp();
      $socketJoinChat(chatData.value._id);
    }
  }
});

onUnmounted(() => {
  if (observer.value) {
    observer.value.disconnect();
  }
  
  // Отписываемся от WebSocket событий при уничтожении компонента
  const { $socket } = useNuxtApp();
  if ($socket) {
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    
    // Если есть активный чат, покидаем его комнату
    if (chatData.value && chatData.value._id) {
      const { $socketLeaveChat } = useNuxtApp();
      $socketLeaveChat(chatData.value._id);
    }
  }
  
  // Удаляем обработчик изменения размера окна
  window.removeEventListener('resize', checkMobile);
});

// Следим за изменением активного чата
watch(() => chatStore.activeChat, (newChat, oldChat) => {
  // Если был активен другой чат, покидаем его комнату
  if (oldChat && oldChat._id) {
    const { $socketLeaveChat } = useNuxtApp();
    $socketLeaveChat(oldChat._id);
  }
  
  // Если выбран новый чат, подключаемся к его комнате
  if (newChat && newChat._id) {
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(newChat._id);
    
    // Обновляем WebSocket слушатели
    setupWebSocketListeners();
  }
  
  nextTick(() => {
    setupInfiniteScroll();
    scrollToBottom(true);
    
    // На мобильных устройствах скрываем sidebar при выборе чата
    if (isMobile.value) {
  selectChatMobile();
}
  });
});

// Следим за изменениями в сообщениях
watch(messages, (newMessages) => {
  if (Array.isArray(newMessages)) {
    visibleMessages.value = newMessages;
    // Используем requestAnimationFrame для оптимизации производительности
    requestAnimationFrame(() => {
      nextTick(() => {
        scrollToBottom(true);
      });
    });
  }
}, { deep: true });

// Добавление новой строки при нажатии Shift+Enter
// Обработка нажатия клавиши Enter
const handleEnterKey = () => {
  // На мобильных устройствах Enter добавляет новую строку
  if (isMobile.value) {
    addNewLine();
  } else {
    // На десктопе Enter отправляет сообщение
    sendMessage();
  }
};

// Добавление новой строки при нажатии Shift+Enter
const addNewLine = () => {
  messageText.value += '\n';
  nextTick(() => {
    adjustTextareaHeight();
  });
};

// Автоматическая адаптация высоты textarea при вводе
const adjustTextareaHeight = () => {
  if (!messageInput.value || !inputArea.value || !messagesContainer.value) return;

  // Сначала сбрасываем высоту, чтобы получить правильный scrollHeight
  messageInput.value.style.height = 'auto';

  // Ограничиваем максимальную высоту
  const maxHeight = 150;
  const minHeight = 44; // Минимальная высота равна высоте кнопки

  // Вычисляем новую высоту на основе содержимого
  const scrollHeight = messageInput.value.scrollHeight;
  const newHeight = Math.min(maxHeight, Math.max(minHeight, scrollHeight));

  // Устанавливаем новую высоту textarea
  messageInput.value.style.height = `${newHeight}px`;

  // Получаем высоту .input_area (включая padding и возможный индикатор редактирования)
  const inputAreaHeight = inputArea.value.offsetHeight;

  // Получаем высоту .page_header
  const headerHeight = pageHeader.value ? pageHeader.value.offsetHeight : 60; // Фоллбэк на 60px

  // Обновляем max-height для .messages_container
  messagesContainer.value.style.maxHeight = `calc(100vh - ${headerHeight}px - ${inputAreaHeight}px)`;
};

// Функция отладки WebSocket
const debugWebSocket = () => {
  const { $socket, $socketConnect } = useNuxtApp();
  
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // alert(`WebSocket: ${$socket.connected ? 'Подключен' : 'Отключен'}`);
  
  if (!$socket.connected) {
    // alert('Попытка переподключения WebSocket...');
    
    // Перед подключением удаляем все обработчики и перенастраиваем их
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    $socket.off('joined-chat');
    
    // Пробуем переключиться на polling, если есть проблемы с websocket
    $socket.io.opts.transports = ['polling', 'websocket'];
    
    // Переподключаемся
    $socketConnect();
    
    // Перенастраиваем слушатели после переподключения
    setTimeout(() => {
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 1000);
  } else if (chatData.value && chatData.value._id) {
    // alert(`Переподключились к чату: ${chatData.value.name}`);
    
    // Проверяем подключение к комнате чата
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(chatData.value._id);
    
    // Перенастраиваем слушатели
    setupWebSocketListeners();
    
    // Пробуем перезагрузить сообщения чата
    chatStore.fetchMessages(chatData.value._id);
  }
};

// Настройка WebSocket слушателей
const setupWebSocketListeners = () => {
  // Получаем доступ к WebSocket
  const { $socket, $socketConnect, $socketJoinChat } = useNuxtApp();
  
  // Проверяем, что у нас есть доступ к сокету
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // Убедимся, что WebSocket подключен
  ifartement: true
});

// Добавление новой строки при нажатии Shift+Enter
const addNewLine = () => {
  messageText.value += '\n';
  nextTick(() => {
    adjustTextareaHeight();
  });
};

// Автоматическая адаптация высоты textarea при вводе
const adjustTextareaHeight = () => {
  if (!messageInput.value || !inputArea.value || !messagesContainer.value) return;

  // Сначала сбрасываем высоту, чтобы получить правильный scrollHeight
  messageInput.value.style.height = 'auto';

  // Ограничиваем максимальную высоту
  const maxHeight = 150;
  const minHeight = 44; // Минимальная высота равна высоте кнопки

  // Вычисляем новую высоту на основе содержимого
  const scrollHeight = messageInput.value.scrollHeight;
  const newHeight = Math.min(maxHeight, Math.max(minHeight, scrollHeight));

  // Устанавливаем новую высоту textarea
  messageInput.value.style.height = `${newHeight}px`;

  // Получаем высоту .input_area (включая padding и возможный индикатор редактирования)
  const inputAreaHeight = inputArea.value.offsetHeight;

  // Получаем высоту .page_header
  const headerHeight = pageHeader.value ? pageHeader.value.offsetHeight : 60; // Фоллбэк на 60px

  // Обновляем max-height для .messages_container
  messagesContainer.value.style.maxHeight = `calc(100vh - ${headerHeight}px - ${inputAreaHeight}px)`;
};

// Функция отладки WebSocket
const debugWebSocket = () => {
  const { $socket, $socketConnect } = useNuxtApp();
  
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // alert(`WebSocket: ${$socket.connected ? 'Подключен' : 'Отключен'}`);
  
  if (!$socket.connected) {
    // alert('Попытка переподключения WebSocket...');
    
    // Перед подключением удаляем все обработчики и перенастраиваем их
    $socket.off('connect');
    $socket.off('new-message');
    $socket.off('messages-read');
    $socket.off('joined-chat');
    
    // Пробуем переключиться на polling, если есть проблемы с websocket
    $socket.io.opts.transports = ['polling', 'websocket'];
    
    // Переподключаемся
    $socketConnect();
    
    // Перенастраиваем слушатели после переподключения
    setTimeout(() => {
      setupWebSocketListeners();
      
      // Если есть активный чат, подключаемся к его комнате
      if (chatData.value && chatData.value._id) {
        const { $socketJoinChat } = useNuxtApp();
        $socketJoinChat(chatData.value._id);
      }
    }, 1000);
  } else if (chatData.value && chatData.value._id) {
    // alert(`Переподключились к чату: ${chatData.value.name}`);
    
    // Проверяем подключение к комнате чата
    const { $socketJoinChat } = useNuxtApp();
    $socketJoinChat(chatData.value._id);
    
    // Перенастраиваем слушатели
    setupWebSocketListeners();
    
    // Пробуем перезагрузить сообщения чата
    chatStore.fetchMessages(chatData.value._id);
  }
};

// Настройка WebSocket слушателей
const setupWebSocketListeners = () => {
  // Получаем доступ к WebSocket
  const { $socket, $socketConnect, $socketJoinChat } = useNuxtApp();
  
  // Проверяем, что у нас есть доступ к сокету
  if (!$socket) {
    // alert('WebSocket не инициализирован');
    return;
  }
  
  // Убедимся, что WebSocket подключен
  if (!$socket.connected) {
    $socketConnect();
  } else {
    // alert('WebSocket уже подключен');
    
    // Если сокет уже подключен и есть активный чат, сразу подключаемся к комнате
    if (chatData.value && chatData.value._id) {
      $socketJoinChat(chatData.value._id);
    }
  }
  
  // Удаляем существующие обработчики, чтобы избежать дублирования
  $socket.off('connect');
  $socket.off('new-message');
  $socket.off('messages-read');
  $socket.off('joined-chat');
  
  // Подписываемся на события WebSocket
  $socket.on('connect', () => {
    // alert('WebSocket подключен успешно');
    
    // Если есть активный чат, подключаемся к его комнате
    if (chatData.value && chatData.value._id) {
      $socketJoinChat(chatData.value._id);
    }
  });
  
  // Обработчик успешного подключения к комнате чата
  $socket.on('joined-chat', ({ chatId, success }) => {
    // alert(`Подключение к комнате чата ${chatId}: ${success ? 'успешно' : 'не удалось'}`);
  });
  
  // Слушаем новые сообщения
  $socket.on('new-message', ({ message, chatId }) => {
    // alert('Получено новое сообщение через WebSocket:', message, 'для чата:', chatId);
    
    // Если сообщение для текущего чата, добавляем его в список
    if (chatData.value && chatData.value._id === chatId) {
      // Проверяем, не добавлено ли уже это сообщение (избегаем дубликатов)
      const isDuplicate = chatStore.messages.some(m => m._id === message._id);
      if (isDuplicate) {
        // alert('Дублирующееся сообщение проигнорировано:', message._id);
        return;
      }
      
      // alert('Добавляем новое сообщение в чат:', message);
      
      // Для изображений, предварительно загружаем их перед добавлением в список сообщений
      if (message.media_type === 'image' && message.file) {
        // Инициализируем флаг загрузки изображения
        message.imageLoaded = false;
        
        // Добавляем сообщение сразу, чтобы показать загрузчик
        chatStore.messages.push({...message});
        
        const img = new Image();
        img.onload = () => {
          // Находим сообщение в массиве и обновляем его статус
          const msgIndex = chatStore.messages.findIndex(m => m._id === message._id);
          if (msgIndex !== -1) {
            // Устанавливаем флаг, что изображение загружено
            chatStore.messages[msgIndex].imageLoaded = true;
          }
          
          // Прокручиваем к новому сообщению, если пользователь находится внизу чата
          if (isAtBottom.value) {
            nextTick(() => {
              scrollToBottom(true);
            });
          } else {
            // Показываем индикатор нового сообщения
            showNewMessageIndicator.value = true;
          }
        };
        img.onerror = () => {
          // alert('Ошибка загрузки изображения:', message.file);
          
          // Находим сообщение в массиве и обновляем его статус
          const msgIndex = chatStore.messages.findIndex(m => m._id === message._id);
          if (msgIndex !== -1) {
            // Помечаем как загруженное, чтобы не показывать бесконечную загрузку
            chatStore.messages[msgIndex].imageLoaded = true;
          }
          
          if (isAtBottom.value) {
            nextTick(() => {
              scrollToBottom(true);
            });
          } else {
            showNewMessageIndicator.value = true;
          }
        };
        img.src = message.file;
      } else {
        // Для не-изображений добавляем сообщение сразу
        chatStore.messages.push({...message});
        
        // Прокручиваем к новому сообщению, если пользователь находится внизу чата
        if (isAtBottom.value) {
          nextTick(() => {
            scrollToBottom(true);
          });
        } else {
          // Показываем индикатор нового сообщения
          showNewMessageIndicator.value = true;
        }
        
        // Прокручиваем к новому сообщению, если пользователь находится внизу чата
        if (isAtBottom.value) {
          nextTick(() => {
            scrollToBottom(true);
          });
        } else {
          // Показываем индикатор нового сообщения
          showNewMessageIndicator.value = true;
        }
      }
      
      // Если сообщение не от текущего пользователя, отмечаем его как прочитанное
      if (message.sender && message.sender._id !== authStore.user._id) {
        chatStore.markMessagesAsRead(chatId);
      }
    }
  });
  
  // Слушаем прочтение сообщений
  $socket.on('messages-read', ({ chatId, userId }) => {
    // alert('Сообщения отмечены как прочитанные:', { chatId, userId });
    
    // Обновляем статус прочтения сообщений в текущем чате
    if (chatData.value && chatData.value._id === chatId) {
      chatStore.updateMessagesReadStatus(chatId, userId);
    }
  });
};

const openChatSettings = () => {
  showChatSettingsModal.value = true;
};
</script>

<style lang="sass">
@import '@variables'

.chat-page
  height: 100vh
  width: 100%
  display: flex
  flex-direction: column
  position: relative
  
  .page_header
    padding: 10px 
    background-color: $header-bg
    display: flex
    align-items: center
    justify-content: space-between
    border-bottom: 1px solid rgba(255, 255, 255, 0.1)
    
    // Кнопка переключения боковой панели
    .toggle-sidebar-btn
      display: none
      background: transparent
      border: none
      color: $white
      font-size: 20px
      cursor: pointer
      padding: 5px 10px
      margin-right: 10px
      transition: all 0.2s ease

      &__icon
        transform: rotate(90deg)
      
      &:hover
        color: rgba(255, 255, 255, 0.8)
      
      @include tablet
        display: block
    
    .content
      display: flex
      align-items: center
      
      &__img
        width: 50px
        height: 50px
        border-radius: 50%
        margin-right: 10px
        background-color: $purple
        background-size: cover
        background-position: center
        display: flex
        align-items: center
        justify-content: center
        
        .initials
          font-size: 18px
          font-weight: bold
          color: $white
        
      &__textblock
        display: flex
        flex-direction: column
        
        .text
          color: $white
          
          &.bold
            font-weight: bold
            font-size: 16px
          
          &.member
            font-size: 12px
            color: rgba(255, 255, 255, 0.7)
    
    .chat-actions
      margin-left: auto
      display: flex
      gap: 10px
      
      .action-btn
        background-color: rgba(255, 255, 255, 0.1)
        color: $white
        border: none
        border-radius: 50%
        width: 36px
        height: 36px
        display: flex
        align-items: center
        justify-content: center
        cursor: pointer
        
        &:hover
          background-color: rgba(255, 255, 255, 0.2)
        
        .icon
          font-size: 18px
  
  .no-chat-selected
    flex: 1
    display: flex
    align-items: center
    justify-content: center
    color: rgba(255, 255, 255, 0.5)
    font-size: 18px
  
  .chat-content
    display: flex
    flex-direction: column
    height: 100%
    width: 100%
    overflow: hidden
  
  .messages_container
    flex: 1 1 auto
    overflow-y: auto
    padding: 0px 20px
    display: flex
    width: 100%
    flex-direction: column
    position: relative
    z-index: 1
    @include custom-scrollbar
    >*
      max-width: 700px;
      width: 100%;
      align-self: center;
    
    .loading-trigger
      height: 20px
      margin-bottom: 10px
    
    .loading-indicator 
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
      color: $white;
      
      &.loading-more 
        margin-bottom: 10px;
        opacity: 0.7;
      
      
      &.initial-loading 
        height: 100px;
        margin: auto;
      
      
      .spinner 
        width: 20px
        height: 20px
        border: 2px solid rgba(255, 255, 255, 0.3)
        border-radius: 50%
        border-top-color: $white
        animation: spin 1s ease-in-out infinite
        margin-right: 10px
        will-change: transform; // Оптимизация для анимации
    
    .empty-chat
      text-align: center
      padding: 30px
      color: rgba(255, 255, 255, 0.5)
    
    .date-header
      text-align: center
      margin: 15px 0
      
      span
        background-color: rgba(255, 255, 255, 0.1)
        color: $white
        padding: 5px 10px
        border-radius: 10px
        font-size: 12px
    
    .service_message
      text-align: center
      margin: 10px 0
      color: rgba(255, 255, 255, 0.7)
      font-size: 12px
      
      .time
        margin-top: 5px
        font-size: 10px
        opacity: 0.7
    
    .message_wrap
      margin-bottom: 10px
      width: 100%
      display: flex
      flex-direction: column
      
      .message
        display: flex
        flex-direction: column
        max-width: 70%
        margin-bottom: 5px
        
        &.own
          align-self: flex-end
          
          .message__content
            background-color: $purple
            border-radius: 15px 15px 0 15px
            margin-left: auto
        
        &.other
          align-self: flex-start
          
          .message__content
            background-color: $header-bg
            border-radius: 15px 15px 15px 0
        
        &__content
          padding: 10px 15px
          color: $white
          word-break: break-word
        
        &__from
          color: rgba(255, 255, 255, 0.8)
          font-weight: bold
          margin-bottom: 5px
          font-size: 14px
        
        &__text
          color: $white
          
          pre
            font-family: inherit
            margin: 0
            white-space: pre-wrap
            word-break: break-word
        
        &__time
          text-align: right
          font-size: 10px
          color: rgba(255, 255, 255, 0.6)
          margin-top: 5px
        
        .video-container, .image-container
          margin: 5px 0
          position: relative
          
          .video-message-player, .message-image
            max-width: 100%
            border-radius: 8px
            max-height: 300px
            opacity: 0
            transition: opacity 0.3s ease-in-out
            
            &.loaded
              opacity: 1
          
          .image-loading
            position: absolute
            top: 0
            left: 0
            width: 100%
            height: 100%
            display: flex
            align-items: center
            justify-content: center
            background-color: rgba(0, 0, 0, 0.1)
            z-index: 2
            border-radius: 8px
            
            .loading-spinner
              width: 30px
              height: 30px
              border: 3px solid rgba(255, 255, 255, 0.3)
              border-radius: 50%
              border-top-color: $purple
              animation: spin 1s ease-in-out infinite
              margin: 0 auto
              background-color: transparent
              will-change: transform; // Оптимизация для анимации
    
        .sticker-container
          .message-sticker
            max-width: 120px
            max-height: 120px
        
        .file-container
          margin: 5px 0
          
          .file-link
            display: flex
            align-items: center
            color: $white
            text-decoration: none
            background-color: rgba(255, 255, 255, 0.1)
            padding: 8px 12px
            border-radius: 8px
            
            &:hover
              background-color: rgba(255, 255, 255, 0.2)
            
            .file-icon
              margin-right: 8px
              font-size: 16px
  
  .input_area
    align-self: center
    max-width: 700px
    width: 100%
    padding: 15px
    flex: 0 0 auto
    position: relative
    z-index: 2
    
    .editing-indicator
      display: flex
      align-items: center
      justify-content: space-between
      padding: 5px 10px
      background-color: rgba(255, 255, 255, 0.1)
      border-radius: 10px
      margin-bottom: 10px
      
      .editing-text
        color: $white
        font-size: 14px
        
        i
          margin-right: 5px
      
      .cancel-btn
        background-color: transparent
        border: none
        color: $white
        font-size: 16px
        cursor: pointer
        
        &:hover
          color: rgba(255, 255, 255, 0.8)
    
    .input_container
      display: flex
      align-items: flex-end
      gap: 10px
      position: relative
      
      .message_input
        flex: 1
        // Дополнительные стили, основные уже в классе inp--textarea
      
      .button_container
        width: 44px
        height: 44px
        
        .send_button
          background-color: $purple
          color: $white
          border: none
          border-radius: 50%
          width: 44px
          height: 44px
          display: flex
          align-items: center
          justify-content: center
          cursor: pointer
          
          &:hover
            background-color: darken($purple, 10%)
          
          &:disabled
            opacity: 0.5
            cursor: not-allowed
          
          i
            font-size: 18px

  
@keyframes spin
  0%
    transform: rotate(0deg)
  100%
    transform: rotate(360deg)


.scroll-btn-enter-active, .scroll-btn-leave-active
  transition: opacity 0.5s ease, transform 0.5s ease

.scroll-btn-enter-from, .scroll-btn-leave-to
  opacity: 0
  transform: translateY(20px)


@include mobile
  .chat-page
    display: flex
    flex-direction: column
    height: 100vh
    overflow: hidden
    
    .chat-content
      display: flex
      flex-direction: column
      height: 100%
      width: 100%
      overflow: hidden
      
    .page_header
      flex: 0 0 auto
      
    .messages_container
      flex: 1 1 auto
      overflow-y: auto
      position: relative
      z-index: 1
      min-height: 0 // Предотвращает переполнение
      
    .input_area
      flex: 0 0 auto
      width: 100%
      z-index: 2
      padding: 10px
      position: relative
      
    .message_wrap
      .message
        max-width: 90%

.image-container
  position: relative
  margin: 5px 0
  max-width: 300px
  
  .image-loading
    position: absolute
    top: 0
    left: 0
    width: 100%
    height: 100%
    display: flex
    align-items: center
    justify-content: center
    background-color: rgba(0, 0, 0, 0.2)
    z-index: 2
    border-radius: 8px
    
    .loading-spinner
      width: 30px
      height: 30px
      border: 3px solid rgba(255, 255, 255, 0.3)
      border-radius: 50%
      border-top-color: $purple
      animation: spin 1s ease-in-out infinite
      margin: 0 auto
      background-color: transparent
      will-change: transform; // Оптимизация для анимации
    
  .message-image
    max-width: 100%
    border-radius: 8px
    opacity: 0.7
    transition: opacity 0.3s ease
    
    &.loaded
      opacity: 1
</style>